{"google":"","note":"Don't delete this file! It's used internally to help with page regeneration.","name":"libdrunkard","body":"## A Drunk Introduction\r\nIf you're looking to procedurally generate 2D maps, libdrunkard may be what you're looking for. This C library uses a fine tuned drunkard's walk alogirithm (see: http://en.wikipedia.org/wiki/Random_walk). Basically, you'll have a walker (or a drunk, as this library calls it) who walks around the map carving tunnels and various other structures.\r\n\r\nHere are some good examples of what you can create (quite simply too! see examples/screen_shotter):\r\n\r\n<table width=\"100%\" border=\"0\" padding=\"0\"><tr>\r\n<td><a href=\"http://dl.dropbox.com/u/11665683/drunkard1.png\">\r\n<img src=\"http://dl.dropbox.com/u/11665683/drunkard1.png\" alt=\"libdrunkard\"></img>\r\n</a></td>\r\n<td><a href=\"http://dl.dropbox.com/u/11665683/drunkard2.png\">\r\n<img src=\"http://dl.dropbox.com/u/11665683/drunkard2.png\" alt=\"libdrunkard\"></img>\r\n</a></td>\r\n</tr><tr>\r\n<td><a href=\"http://dl.dropbox.com/u/11665683/drunkard3.png\">\r\n<img src=\"http://dl.dropbox.com/u/11665683/drunkard3.png\" alt=\"Playing with different tiles for each new dig.\"></img>\r\n</a></td>\r\n<td><a href=\"http://dl.dropbox.com/u/11665683/drunkard4.png\"><img src=\"http://dl.dropbox.com/u/11665683/drunkard4.png\" alt=\"Playing with different tiles for each new dig.\"></img>\r\n</a></td>\r\n</tr></table>\r\n\r\n## Compiling Drunkard\r\n\r\nOn most systems, you can simply do `make && make install` to get the library working on your computer. The library itself is very small, 57kb with debugging enabled.\r\n\r\nIf libdrunkard fails to compile on your system, feel free to contact me at my GitHub: @jabb.\r\n\r\n## Using Drunkard\r\n\r\n### A Brief Example\r\n\r\nIn order to use libdrunkard, all you need to do is include the header file `<dunkard.h>` and link against the library by passing `-ldrunkard` to GCC, or some other compiler. After that you need to have your map already defined and then you can create your drunk. The map needs to be an array or multidimensional array of unsigned numbers, if multidimensional, height must be indexed first, like below:\r\n\r\n```\r\nunsigned map[MAP_HEIGHT][MAP_WIDTH] = {{0}};\r\n/* Create the drunk. */\r\nstruct drunkard *drunk = drunkard_create((void *)map, MAP_WIDTH, MAP_HEIGHT);\r\n\r\n/* Carve out a random map. */\r\n/* ... */\r\n\r\n/* Destroy the drunk. */\r\ndrunkard_destroy(drunk);\r\n```\r\n\r\nSome technical notes:\r\n\r\n* libdrunkard uses it's own internal random number generator (CMWC) which is seeded automatically. You can get the current seed with `drunkard_get_seed` and set it manually with `drunkard_seed`.\r\n* libdrunkard recognizes numbers passing a certain threshold as open (walkable) tiles. This threshold can be set manually with `drunkard_set_opened_threshold`. The default is 1, so only a tile that has the value of 0 can't be walked upon.\r\n* libdrunkard keeps a list of tiles that have been opened and tiles that might be opened after a flush, the latter are called marks. \"Marking\" tiles is the preferable way to set tiles during a carving process, that way any tiles that open up don't confuse the drunkard into thinking he's found the main tunnel system. There are various marking functions, but only one way to flush them: `drunkard_flush_marks`. Flush only when you're absolutely sure you've connected with the rest of your walkable area, or you know you can get back to the disconnected area.\r\n* libdrunkard's marks tiles only relative to the current position and target of the drunk. When you're carving, at some point you should **always** target a random open tile and head towards it. There are always exceptions of course, but this is a good rule so you can be sure your drunk connects to a walkable area.\r\n* libdrunkard's main stepping function uses a weight to calculate how stumbly the drunk will be. The weight is on a scale from 0.0 to 1.0. A value of 0.0 means the drunk will move directly away from his target, a value of 1.0 will mean directory towards, and a value of 0.5 means he'll just randomly walk around. I like values between 0.6 and 0.9 to be sure the drunk reaches his target.\r\n\r\n### A More Involved Example (examples/cave.c)\r\n\r\n```\r\n#include <stdio.h>\r\n\r\n#include \"drunkard.h\"\r\n\r\n/* Our map's dimensions. */\r\n#define WIDTH   80\r\n#define HEIGHT  24\r\n\r\n/* By default, the drunk recognizes anything above 0 to be open space, ie\r\n * walkable.\r\n */\r\nenum {WALL, FLOOR};\r\n\r\n/* This function simply outputs our map to the console. */\r\nvoid output_map(unsigned map[HEIGHT][WIDTH]);\r\n\r\nint main(void)\r\n{\r\n    /* Create our map. Making sure the default value is our WALL. It is\r\n     * important to note that the drunk indexes in a way that the height needs\r\n     * to be specified first.\r\n     */\r\n    unsigned map[HEIGHT][WIDTH] = {{WALL}};\r\n\r\n    /* Now we need to create our poor drunk to wonder the map. */\r\n    struct drunkard *drunk = drunkard_create((void *)map, WIDTH, HEIGHT);\r\n\r\n    /* A lot of the drunk's navigating is done by knowing where places he can\r\n     * walk are. If there are no places he can walk, he'll just walk aimlessly\r\n     * and may never connect to the rest of the map if there is one. We can't\r\n     * allow that.\r\n     *\r\n     * Here we carve a \"seed\". This seed is a walkable tile that a drunk can\r\n     * walk to.\r\n     */\r\n    /* First he'll start on a random place on the map. */\r\n    drunkard_start_random(drunk);\r\n    /* Then he marks the spot he's on at a \"FLOOR\", which the drunk knows is\r\n     * walkable.\r\n     */\r\n    drunkard_mark_1(drunk, FLOOR);\r\n    /* Now we have to \"flush\" the changes. I'll talk more about what flushing\r\n     * does later.\r\n     */\r\n    drunkard_flush_marks(drunk);\r\n\r\n    /* Now we have our seed, we can start carving does cool maps. We're going\r\n     * to carve a VERY simple cave. The drunk will only carve once.\r\n     */\r\n     /* Start in a random location. */\r\n    drunkard_start_random(drunk);\r\n     /* Here's where we use our drunk's knowledge to target a place he knows\r\n      * he can walk. This will target our seed, since it's the only open tile.\r\n      */\r\n    drunkard_target_random_opened(drunk);\r\n\r\n     /* Here's the tricky part. We're going to walk towards our target until we\r\n      * reach it or until we come across another open tile (hardly!).\r\n      */\r\n    while (!drunkard_is_on_target(drunk) || !drunkard_is_on_opened(drunk))\r\n    {\r\n        /* Mark a plus symbol of FLOORs. The plus is a cool way to carve through\r\n         * a map. It doesn't ever leave tight diagonals to maneuver around, and\r\n         * it's quite spacious!\r\n         */\r\n        drunkard_mark_plus(drunk, FLOOR);\r\n        /* We can step to the target in a variety of ways and with different\r\n         * weights. The weight value goes from 0 to 1. 0 basically means the\r\n         * drunk will be moving AWAY from his target. 1 will cause the drunk\r\n         * to go straight towards his target. And 0.5 he'll wander aimlessly,\r\n         * and may never reach his target. I like a value from 0.6 to 0.9. We'll\r\n         * use 0.6 for drunk that wanders a lot.\r\n         */\r\n        drunkard_step_to_target(drunk, 0.6);\r\n    }\r\n\r\n    /* Finally, let's output our map! */\r\n    output_map(map);\r\n\r\n    /* Always destroy the drunk when you're done with him! */\r\n    drunkard_destroy(drunk);\r\n\r\n    return 0;\r\n}\r\n\r\nvoid output_map(unsigned map[HEIGHT][WIDTH])\r\n{\r\n    for (int y = 0; y < HEIGHT; ++y)\r\n    {\r\n        for (int x = 0; x < WIDTH; ++x)\r\n        {\r\n            printf(\"%c\", map[y][x] ? '.' : '#');\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n```\r\n\r\n## Function Documentation\r\n\r\n### Drunk Creation/Destruction\r\n\r\n```\r\nstruct drunkard *drunkard_create(unsigned *tiles, unsigned width, unsigned height);\r\nvoid drunkard_destroy(struct drunkard *drunk);\r\n```\r\n\r\nIn order to use the drunk, you have to create him. He takes a pointer to an array of unsigned integers. These integers will mostly likely be key-lookups to table of your real tiles. `drunkard_create` returns `NULL` only if there is no memory left. After you're done, be sure to destroy it, freeing any resources.\r\n\r\n### Core Functions\r\n\r\n```\r\nbool drunkard_is_opened(struct drunkard *drunk, int x, int y);\r\nvoid drunkard_set_open_threshold(struct drunkard *drunk, unsigned threshold);\r\nvoid drunkard_mark(struct drunkard *drunk, int x, int y, unsigned tile);\r\nvoid drunkard_flush_marks(struct drunkard *drunk);\r\n```\r\n\r\n`drunkard_is_opened` checks the tile at `x, y` and returns true if it is opened (walkable).\r\n\r\n`drunkard_set_open_threshold` sets the threshold for open tiles. Anything greater than or equal to this number are considered by the drunk walkable.\r\n\r\n`drunkard_mark` marks a tile. If the tile is an open one (walkable), it is added to the list of marked tiles. If the tile is closed (unwalkable), it is removed from the list of open tiles and list marked tiles.\r\n\r\n`drunkard_flush_marks` flushes all the marked tiles to the list of open tiles. The marked list is then cleared.\r\n\r\n### Querying Functions\r\n\r\n```\r\nunsigned drunkard_count_opened(struct drunkard *drunk);\r\ndouble drunkard_percent_opened(struct drunkard *drunk);\r\nvoid drunkard_random_opened(struct drunkard *drunk, unsigned *x, unsigned *y);\r\n\r\nint drunkard_get_x(struct drunkard *drunk);\r\nint drunkard_get_y(struct drunkard *drunk);\r\nint drunkard_get_target_x(struct drunkard *drunk);\r\nint drunkard_get_target_y(struct drunkard *drunk);\r\nint drunkard_get_dx_to_target(struct drunkard *drunk);\r\nint drunkard_get_dy_to_target(struct drunkard *drunk);\r\n```\r\n\r\n`drunkard_count_opened` returns the number of opened tiles on the map. (Doesn't include marked.)\r\n\r\n`drunkard_percent_opened` returns the percent of the tiles opened on the map. Half the map opened would be 0.5.\r\n\r\n`drunkard_random_opened` sets `x` and `y` to a random opened point on the map. (Doesn't include marked.)\r\n\r\nThe rest of the functions should be self explanatory.\r\n\r\n### Random Number Generation\r\n\r\n```\r\nunsigned drunkard_get_seed(struct drunkard *drunk);\r\nvoid drunkard_seed(struct drunkard *drunk, unsigned s);\r\ndouble drunkard_rng_uniform(struct drunkard *drunk);\r\ndouble drunkard_rng_under(struct drunkard *drunk, unsigned limit);\r\nint drunkard_rng_range(struct drunkard *drunk, int low, int high);\r\nbool drunkard_rng_chance(struct drunkard *drunk, double d);\r\n```\r\n\r\n`drunkard_get_seed` returns the current seed.\r\n\r\n`drunkard_seed` sets the current seed.\r\n\r\n`drunkard_rng_uniform` returns a double in the range [0, 1).\r\n\r\n`drunkard_rng_under` returns a double in the range [0, limit).\r\n\r\n`drunkard_rng_range` returns an int in the range [low, high].\r\n\r\n`drunkard_rng_chance` returns true `d` percent of the time.\r\n\r\n### Starting/Targeting Functions\r\n\r\n```\r\nvoid drunkard_start_fixed(struct drunkard *drunk, int x, int y);\r\nvoid drunkard_start_random(struct drunkard *drunk);\r\nvoid drunkard_start_random_west(struct drunkard *drunk);\r\nvoid drunkard_start_random_east(struct drunkard *drunk);\r\nvoid drunkard_start_random_north(struct drunkard *drunk);\r\nvoid drunkard_start_random_south(struct drunkard *drunk);\r\nvoid drunkard_start_random_west_edge(struct drunkard *drunk);\r\nvoid drunkard_start_random_east_edge(struct drunkard *drunk);\r\nvoid drunkard_start_random_north_edge(struct drunkard *drunk);\r\nvoid drunkard_start_random_south_edge(struct drunkard *drunk);\r\nvoid drunkard_start_random_westeast_edge(struct drunkard *drunk);\r\nvoid drunkard_start_random_northsouth_edge(struct drunkard *drunk);\r\nvoid drunkard_start_random_edge(struct drunkard *drunk);\r\nvoid drunkard_start_random_opened(struct drunkard *drunk);\r\n\r\nvoid drunkard_target_fixed(struct drunkard *drunk, int x, int y);\r\nvoid drunkard_target_random_west_edge(struct drunkard *drunk);\r\nvoid drunkard_target_random_east_edge(struct drunkard *drunk);\r\nvoid drunkard_target_random_north_edge(struct drunkard *drunk);\r\nvoid drunkard_target_random_south_edge(struct drunkard *drunk);\r\nvoid drunkard_target_random_westeast_edge(struct drunkard *drunk);\r\nvoid drunkard_target_random_northsouth_edge(struct drunkard *drunk);\r\nvoid drunkard_target_random_edge(struct drunkard *drunk);\r\nvoid drunkard_target_random_opened(struct drunkard *drunk);\r\n```\r\n\r\n`drunkard_start_*` functions set the `x, y` location of the drunk. `drunkard_start_random_west` sets the drunk's `x, y` location to a random location on the west side of the map (x >= WIDTH/2). `*_edge` functions are on the outermost edge of the map.\r\n\r\n`drunkard_target_*` functions behave exactly like the `drunkard_start_*` functions, except the set the drunk's target location. Note: `drunkard_target_random_opened` is probably the most important since you always want to try to connect to the rest of your carved area. \r\n\r\n### Marking Functions\r\n\r\n```\r\nvoid drunkard_mark_all(struct drunkard *drunk, unsigned tile);\r\nvoid drunkard_mark_1(struct drunkard *drunk, unsigned tile);\r\nvoid drunkard_mark_plus(struct drunkard *drunk, unsigned tile);\r\nvoid drunkard_mark_x(struct drunkard *drunk, unsigned tile);\r\nvoid drunkard_mark_rect(struct drunkard *drunk, int hw, int hh, unsigned tile);\r\nvoid drunkard_mark_circle(struct drunkard *drunk, int r, unsigned tile);\r\n```\r\n\r\n`drunkard_mark_all` marks every tile on the map. The locations on the map are set to `tile`.\r\n\r\n`drunkard_mark_1` marks the tile the drunk is standing on. The location on the map are set to `tile`.\r\n\r\n`drunkard_mark_plus` marks a plus sign at the drunk's location. A plus sign is the current tile the drunk is standing on and four additional tiles in each cardinal direction from the origin. The locations on the map are set to `tile`.\r\n\r\n`drunkard_mark_x` marks an X at the drunk's location. An X is the current tile the drunk is standing on and four addition tiles in each intermediate direction from the origin. The locations on the map are set to `tile`. The locations on the map are set to `tile`.\r\n\r\n`drunk_mark_rect` marks a rectangle, where the center is at the drunk's location. It's important to note that the integers passed are half the width and height. So passing `3, 3` results in a 7x7 rectangle. The locations on the map are set to `tile`.\r\n\r\n`drunk_mark_circle` marks a circle, where the center is at the drunk's location. The locations on the map are set to `tile`.\r\n\r\n### Stepping Functions\r\n\r\n```\r\nvoid drunkard_step_by(struct drunkard *drunk, int dx, int dy);\r\nvoid drunkard_step_random(struct drunkard *drunk);\r\nvoid drunkard_step_to_target(struct drunkard *drunk, double weight);\r\n\r\nvoid drunkard_line_path_to_target(struct drunkard *drunk);\r\nvoid drunkard_tunnel_path_to_target(struct drunkard *drunk);\r\nbool drunkard_walk_path(struct drunkard *drunk);\r\n```\r\n\r\nWhen the drunk has a starting location and a target, he needs a way to get there. Stepping functions help. There are even pathing functions to plan out a very specific path to the target. All the stepping only occurs in four directions, six and eight-directional support is planned.\r\n\r\n`drunkard_step_by` has the drunk step by delta x and delta y values.\r\n\r\n`drunkard_step_random` just steps randomly in four directions.\r\n\r\n`drunkard_step_to_target` a weighted step towards the target. Only moves in four directions.\r\n\r\nPathing functions:\r\n\r\n`drunkard_line_path_to_target` plans a straight line to the target.\r\n\r\n`drunkard_tunnel_path_to_target` the classic corridor. The choice between going horizontal or vertical first is random (50/50 chance).\r\n\r\n`drunkard_walk_path` walks along the planned path. Returns false when the drunk is at the end, or in other words: on the target.\r\n\r\n### Checking Functions\r\n\r\n```\r\nbool drunkard_is_on_opened(struct drunkard *drunk);\r\nbool drunkard_is_opened_on_rect(struct drunkard *drunk, unsigned hw, unsigned hh);\r\nbool drunkard_is_opened_on_circle(struct drunkard *drunk, unsigned r);\r\nbool drunkard_is_on_target(struct drunkard *drunk);\r\nbool drunkard_is_on_fixed(struct drunkard *drunk, int x, int y);\r\nbool drunkard_is_on_fixed_x(struct drunkard *drunk, int x);\r\nbool drunkard_is_on_fixed_y(struct drunkard *drunk, int y);\r\n```\r\n\r\nThese are good for breaking out of loops or checking an area to see if it's clear before building on it.\r\n\r\n`drunkard_is_on_opened` returns true if the drunk is standing on an open tile (walkable).\r\n\r\n`drunkard_is_opened_on_rect` returns true if any of the tiles in a rectangle area around the drunk are open.\r\n\r\n`drunkard_is_opened_on_circle` return true if any of the tiles on a circle area around the drunk are open.\r\n\r\n`drunkard_is_on_target` returns true when the drunkard's `x, y` location is equal to the drunk's `target x, target y` location.\r\n\r\n`drunkard_is_on_fixed` returns true when the drunkard's `x, y` location is equal to the passed location.\r\n\r\n`drunkard_is_on_fixed_x` returns true when the drunkard's `x` location is equal to the passed x location.\r\n\r\n`drunkard_is_on_fixed_y` returns true when the drunkard's `y` location is equal to the passed y location.","tagline":"Drunkard's Walk 2D Map Generator written in C"}