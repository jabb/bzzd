<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>libdrunkard by jabb</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>libdrunkard</h1>
        <p>Drunkard's Walk 2D Map Generator</p>

        <p class="view"><a href="https://github.com/jabb/libdrunkard">View the Project on GitHub <small>jabb/libdrunkard</small></a></p>


        <ul>
          <li><a href="https://github.com/jabb/libdrunkard/zipball/master">Download <strong>ZIP File</strong></a></li>
          <li><a href="https://github.com/jabb/libdrunkard/tarball/master">Download <strong>TAR Ball</strong></a></li>
          <li><a href="https://github.com/jabb/libdrunkard">View On <strong>GitHub</strong></a></li>
        </ul>
      </header>
      <section>
        <h2>A Drunk Introduction</h2>

<p>If you're looking to procedurally generate 2D maps, libdrunkard may be what you're looking for. This library uses a fine tuned drunkard's walk alogirithm (see: <a href="http://en.wikipedia.org/wiki/Random_walk">http://en.wikipedia.org/wiki/Random_walk</a>). Basically, you'll have a walker (or a drunk, as this library calls it) who walks around the map carving tunnels and various other structures.</p>

<p>Here are some good examples of what you can create (quite simply too! see examples/screen_shotter):</p>

<table width="100%" border="0">
<tr>
<td><a href="http://dl.dropbox.com/u/11665683/drunkard1.png">
<img src="http://dl.dropbox.com/u/11665683/drunkard1.png" alt="libdrunkard"></a></td>
<td><a href="http://dl.dropbox.com/u/11665683/drunkard2.png">
<img src="http://dl.dropbox.com/u/11665683/drunkard2.png" alt="libdrunkard"></a></td>
</tr>
<tr>
<td><a href="http://dl.dropbox.com/u/11665683/drunkard3.png">
<img src="http://dl.dropbox.com/u/11665683/drunkard3.png" alt="Playing with different tiles for each new dig."></a></td>
<td><a href="http://dl.dropbox.com/u/11665683/drunkard4.png"><img src="http://dl.dropbox.com/u/11665683/drunkard4.png" alt="Playing with different tiles for each new dig."></a></td>
</tr>
</table><h2>Compiling Drunkard</h2>

<p>On most systems, you can simply do <code>make &amp;&amp; make install</code> to get the library working on your computer. The library itself is very small, 57kb with debugging enabled.</p>

<p>If libdrunkard fails to compile on your system, feel free to contact me at my GitHub: <a href="https://github.com/jabb" class="user-mention">@jabb</a>.</p>

<h2>Using Drunkard</h2>

<p>In order to use libdrunkard, all you need to do is include the header file <code>&lt;dunkard.h&gt;</code> and link against the library by passing <code>-ldrunkard</code> to GCC, or some other compiler. After that you need to have your map already defined and then you can create your drunk. The map needs to be an array or multidimensional array of unsigned numbers, if multidimensional, height must be indexed first, like below:</p>

<pre><code>unsigned map[MAP_HEIGHT][MAP_WIDTH] = {{0}};
/* Create the drunk. */
struct drunkard *drunk = drunkard_create((void *)map, MAP_WIDTH, MAP_HEIGHT);

/* Carve out a random map. */
/* ... */

/* Destroy the drunk. */
drunkard_destroy(drunk);
</code></pre>

<p>Some technical notes:</p>

<ul>
<li>libdrunkard uses it's own custom random number generator (CMWC) which is seeded automatically. You can get the current seed with <code>drunkard_get_seed</code> and set it manually with <code>drunkard_seed</code>.</li>
<li>libdrunkard recognizes numbers passing a certain threshold as open (walkable) tiles. This threshold can be set manually with <code>drunkard_set_opened_threshold</code>. The default is 1, so only a tile that has the value of 0 can't be walked upon.</li>
<li>libdrunkard keeps a list of tiles that have been opened and tiles that might be opened after a flush, the latter are called marks. "Marking" tiles is the preferable way to set tiles during a carving process, that way any tiles that open up don't confuse the drunkard thinking he's found the main tunnel system. There are various marking functions, but only one way to flush them: <code>drunkard_flush_marks</code>. Flush only when you're absolutely sure you've connected with the rest of your walkable area, or you know you can get back to the disconnected area.</li>
<li>libdrunkard's marks tiles only relative to the current position and target of the drunk. When you're carving, at some point you should <strong>always</strong> target a random open tile and head towards it. There are always exceptions of course, but this is a good rule so you can be sure your drunk connects to a walkable area.</li>
<li>libdrunkard's main stepping function uses a weight to calculate how stumbly the drunk will be. The weight is on a scale from 0.0 to 1.0. A value of 0.0 means the drunk will move directly away from his target, a value of 1.0 will mean directory towards, and a value of 0.5 means he'll just randomly walk around. I like values between 0.6 and 0.9 to be sure the drunk reaches his target.</li>
</ul><h2>Function Documentation</h2>

<h3>Drunk Creation/Destruction</h3>

<pre><code>struct drunkard *drunkard_create(unsigned *tiles, unsigned width, unsigned height);
void drunkard_destroy(struct drunkard *drunk);
</code></pre>

<p>In order to use the drunk, you have to create him. He takes a pointer to an array of unsigned integers. These integers will mostly likely be key-lookups to table of your real tiles. <code>drunkard_create</code> returns <code>NULL</code> only if there is no memory left. After you're done, be sure to destroy it, freeing any resources.</p>

<h3>Core Functions</h3>

<pre><code>bool drunkard_is_opened(struct drunkard *drunk, int x, int y);
void drunkard_set_open_threshold(struct drunkard *drunk, unsigned threshold);
void drunkard_mark(struct drunkard *drunk, int x, int y, unsigned tile);
void drunkard_flush_marks(struct drunkard *drunk);
</code></pre>

<p><code>drunkard_is_opened</code> checks the tile at <code>x, y</code> and returns true if it is opened (walkable).</p>

<p><code>drunkard_set_open_threshold</code> sets the threshold for open tiles. Anything greater than or equal to this number are considered by the drunk walkable.</p>

<p><code>drunkard_mark</code> marks a tile. If the tile is an open one (walkable), it is added to the list of marked tiles. If the tile is closed (unwalkable), it is removed from the list of open tiles and list marked tiles.</p>

<p><code>drunkard_flush_marks</code> flushes all the marked tiles to the list of open tiles. The marked list is then cleared.</p>

<h3>Querying Functions</h3>

<pre><code>unsigned drunkard_count_opened(struct drunkard *drunk);
double drunkard_percent_opened(struct drunkard *drunk);
void drunkard_random_opened(struct drunkard *drunk, unsigned *x, unsigned *y);

int drunkard_get_x(struct drunkard *drunk);
int drunkard_get_y(struct drunkard *drunk);
int drunkard_get_target_x(struct drunkard *drunk);
int drunkard_get_target_y(struct drunkard *drunk);
int drunkard_get_dx_to_target(struct drunkard *drunk);
int drunkard_get_dy_to_target(struct drunkard *drunk);
</code></pre>

<p><code>drunkard_count_opened</code> returns the number of opened tiles on the map. (Doesn't include marked.)</p>

<p><code>drunkard_percent_opened</code> returns the percent of the tiles opened on the map. Half the map opened would be 0.5.</p>

<p><code>drunkard_random_opened</code> sets <code>x</code> and <code>y</code> to a random opened point on the map. (Doesn't include marked.)</p>

<p>The rest of the functions should be self explanatory.</p>

<h3>Random Number Generation</h3>

<pre><code>unsigned drunkard_get_seed(struct drunkard *drunk);
void drunkard_seed(struct drunkard *drunk, unsigned s);
double drunkard_rng_uniform(struct drunkard *drunk);
double drunkard_rng_under(struct drunkard *drunk, unsigned limit);
int drunkard_rng_range(struct drunkard *drunk, int low, int high);
bool drunkard_rng_chance(struct drunkard *drunk, double d);
</code></pre>

<p><code>drunkard_get_seed</code> returns the current seed.</p>

<p><code>drunkard_seed</code> sets the current seed.</p>

<p><code>drunkard_rng_uniform</code> returns a double in the range [0, 1).</p>

<p><code>drunkard_rng_under</code> returns a double in the range [0, limit).</p>

<p><code>drunkard_rng_range</code> returns an int in the range [low, high].</p>

<p><code>drunkard_rng_chance</code> returns true <code>d</code> percent of the time.</p>

<h3>Starting/Targeting Functions</h3>

<pre><code>void drunkard_start_fixed(struct drunkard *drunk, int x, int y);
void drunkard_start_random(struct drunkard *drunk);
void drunkard_start_random_west(struct drunkard *drunk);
void drunkard_start_random_east(struct drunkard *drunk);
void drunkard_start_random_north(struct drunkard *drunk);
void drunkard_start_random_south(struct drunkard *drunk);
void drunkard_start_random_west_edge(struct drunkard *drunk);
void drunkard_start_random_east_edge(struct drunkard *drunk);
void drunkard_start_random_north_edge(struct drunkard *drunk);
void drunkard_start_random_south_edge(struct drunkard *drunk);
void drunkard_start_random_westeast_edge(struct drunkard *drunk);
void drunkard_start_random_northsouth_edge(struct drunkard *drunk);
void drunkard_start_random_edge(struct drunkard *drunk);
void drunkard_start_random_opened(struct drunkard *drunk);

void drunkard_target_fixed(struct drunkard *drunk, int x, int y);
void drunkard_target_random_west_edge(struct drunkard *drunk);
void drunkard_target_random_east_edge(struct drunkard *drunk);
void drunkard_target_random_north_edge(struct drunkard *drunk);
void drunkard_target_random_south_edge(struct drunkard *drunk);
void drunkard_target_random_westeast_edge(struct drunkard *drunk);
void drunkard_target_random_northsouth_edge(struct drunkard *drunk);
void drunkard_target_random_edge(struct drunkard *drunk);
void drunkard_target_random_opened(struct drunkard *drunk);
</code></pre>

<p><code>drunkard_start_*</code> functions set the <code>x, y</code> location of the drunk. <code>drunkard_start_random_west</code> sets the drunk's <code>x, y</code> location to a random location on the west side of the map (x &gt;= WIDTH/2). <code>*_edge</code> functions are on the outermost edge of the map.</p>

<p><code>drunkard_target_*</code> functions behave exactly like the <code>drunkard_start_*</code> functions, except the set the drunk's target location. Note: <code>drunkard_target_random_opened</code> is probably the most important since you always want to try to connect to the rest of your carved area. </p>

<h3>Marking Functions</h3>

<pre><code>void drunkard_mark_all(struct drunkard *drunk, unsigned tile);
void drunkard_mark_1(struct drunkard *drunk, unsigned tile);
void drunkard_mark_plus(struct drunkard *drunk, unsigned tile);
void drunkard_mark_x(struct drunkard *drunk, unsigned tile);
void drunkard_mark_rect(struct drunkard *drunk, int hw, int hh, unsigned tile);
void drunkard_mark_circle(struct drunkard *drunk, int r, unsigned tile);
</code></pre>

<p><code>drunkard_mark_all</code> marks every tile on the map. The locations on the map are set to <code>tile</code>.</p>

<p><code>drunkard_mark_1</code> marks the tile the drunk is standing on. The location on the map are set to <code>tile</code>.</p>

<p><code>drunkard_mark_plus</code> marks a plus sign at the drunk's location. A plus sign is the current tile the drunk is standing on and four additional tiles in each cardinal direction from the origin. The locations on the map are set to <code>tile</code>.</p>

<p><code>drunkard_mark_x</code> marks an X at the drunk's location. An X is the current tile the drunk is standing on and four addition tiles in each intermediate direction from the origin. The locations on the map are set to <code>tile</code>. The locations on the map are set to <code>tile</code>.</p>

<p><code>drunk_mark_rect</code> marks a rectangle, where the center is at the drunk's location. It's important to note that the integers passed are half the width and height. So passing <code>3, 3</code> results in a 7x7 rectangle.</p>

<p><code>drunk_mark_circle</code> marks a circle, where the center is at the drunk's location. The locations on the map are set to <code>tile</code>.</p>

<h3>Stepping Functions</h3>

<pre><code>void drunkard_step_by(struct drunkard *drunk, int dx, int dy);
void drunkard_step_random(struct drunkard *drunk);
void drunkard_step_to_target(struct drunkard *drunk, double weight);

void drunkard_line_path_to_target(struct drunkard *drunk);
void drunkard_tunnel_path_to_target(struct drunkard *drunk);
bool drunkard_walk_path(struct drunkard *drunk);
</code></pre>

<p>When the drunk has a starting location and a target, he needs a way to get there. Stepping functions help. There are even pathing functions to plan out a very specific path to the target. All the stepping only occurs in four directions, six and eight-directional support is planned.</p>

<p><code>drunkard_step_by</code> has the drunk step by delta x and delta y values.</p>

<p><code>drunkard_step_random</code> just steps randomly in four directions.</p>

<p><code>drunkard_step_to_target</code> a weighted step towards the target. Only moves in four directions.</p>

<p>Pathing functions:</p>

<p><code>drunkard_line_path_to_target</code> plans a straight line to the target.</p>

<p><code>drunkard_tunnel_path_to_target</code> the classic corridor. The choice between going horizontal or vertical first is random (50/50 chance).</p>

<p><code>drunkard_walk_path</code> walks along the planned path. Returns false when the drunk is at the end, or in other words: on the target.</p>

<h3>Checking Functions</h3>

<pre><code>bool drunkard_is_on_opened(struct drunkard *drunk);
bool drunkard_is_opened_on_rect(struct drunkard *drunk, unsigned hw, unsigned hh);
bool drunkard_is_opened_on_circle(struct drunkard *drunk, unsigned r);
bool drunkard_is_on_target(struct drunkard *drunk);
bool drunkard_is_on_fixed(struct drunkard *drunk, int x, int y);
bool drunkard_is_on_fixed_x(struct drunkard *drunk, int x);
bool drunkard_is_on_fixed_y(struct drunkard *drunk, int y);
</code></pre>

<p>These are good for breaking out of loops or checking an area to see if it's clear before building on it.</p>

<p><code>drunkard_is_on_opened</code> returns true if the drunk is standing on an open tile (walkable).</p>

<p><code>drunkard_is_opened_on_rect</code> returns true if any of the tiles in a rectangle area around the drunk are open.</p>

<p><code>drunkard_is_opened_on_circle</code> return true if any of the tiles on a circle area around the drunk are open.</p>

<p><code>drunkard_is_on_target</code> returns true when the drunkard's <code>x, y</code> location is equal to the drunk's <code>target x, target y</code> location.</p>

<p><code>drunkard_is_on_fixed</code> returns true when the drunkard's <code>x, y</code> location is equal to the passed location.</p>

<p><code>drunkard_is_on_fixed_x</code> returns true when the drunkard's <code>x</code> location is equal to the passed x location.</p>

<p><code>drunkard_is_on_fixed_y</code> returns true when the drunkard's <code>y</code> location is equal to the passed y location.</p>
      </section>
      <footer>
        <p>This project is maintained by <a href="https://github.com/jabb">jabb</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="javascripts/scale.fix.js"></script>
    
  </body>
</html>